import os
import sys
import argparse
import subprocess
import shutil

def main():
    parser = argparse.ArgumentParser(description='Run adapt_voxel_recolor.py and retrain based on mode')
    parser.add_argument('--depth_start', type=int, required=True, help='Initial depth for voxelization')
    parser.add_argument('--voxel_thr', type=int, required=True, help='Threshold for small voxel point count')
    parser.add_argument('--dataset_name', type=str, required=True, help='Name of the dataset')
    parser.add_argument('--use_adaptive', type=str, required=True, help='Set to "true" for adaptive voxelization, "false" for uniform voxelization')
    parser.add_argument('--retrain_mode', type=str, required=True,help='Set to "PC" for retrain PC, "3DGS" for retrain 3DGS')
    parser.add_argument('--iterations', type=int, required=True, help='Number of iterations for training')
    args = parser.parse_args()
    
    # Automatically get the directory where the current script is located, and go up one level as the root directory
    current_script_dir = os.path.dirname(os.path.abspath(__file__))
    root_path = os.path.abspath(os.path.join(current_script_dir, ".."))
    print(f"[DEBUG] Root path: {root_path}")
    
    # Step 2: Define your 3-level folder structure
    folder_structure = [
        "attributes_compressed",
        "reconstructed_3DGS",
        "retrain_model",
        "VQ_model",
        "voxelized_adapt",
        "RDO/bpp",
        "RDO/Meta_data",
        "RDO/PSNR",
        "RDO/PSNR_per_view",
    ]

    # Step 3: Create directories
    for relative_path in folder_structure:
        full_path = os.path.join(root_path, relative_path)
        os.makedirs(full_path, exist_ok=True)
        print(f"[INFO] Created folder: {full_path}")

    # Construct the full path of adapt_voxel_recolor.py (this script is located in retrain_3DGS under the root directory)
    script_path = os.path.join(root_path, "code_Adaptive", "retrain_3DGS", "adapt_voxel_recolor.py")
    if not os.path.exists(script_path):
        raise FileNotFoundError(f"Script not found: {script_path}")
    
    # Construct command-line arguments to pass to adapt_voxel_recolor.py
    cmd = [
        sys.executable, script_path,
        "--depth_start", str(args.depth_start),
        "--voxel_thr", str(args.voxel_thr),
        "--dataset_name", args.dataset_name,
        "--use_adaptive", args.use_adaptive,
    ]
    print(f"[DEBUG] Running command: {' '.join(cmd)}")
    subprocess.run(cmd, check=True)
    
    # Set suffix based on --use_adaptive parameter
    if args.use_adaptive.lower() == "true":
        suffix = "_adapt"
    else:
        suffix = "_uniform"
    
    # Output filename pattern generated by adapt_voxel_recolor.py:
    # output_filename_base = {dataset_name}_depth_{depth_start}_thr_{voxel_thr}{suffix}
    output_filename_base = f"{args.dataset_name}_depth_{args.depth_start}_thr_{args.voxel_thr}"
    output_path = os.path.join(root_path, "voxelized_adapt")
    
    # Generated file paths for PC and 3DGS
    pc_ply_file = os.path.join(output_path, f"{output_filename_base}_PC{suffix}.ply")
    full_ply_file = os.path.join(output_path, f"{output_filename_base}_3DGS{suffix}.ply")
    
    # Get the number of training iterations from command-line arguments
    iterations = args.iterations
    
    # Set retrain_mode (converted to lowercase for comparison)
    retrain_mode = args.retrain_mode.lower()
    
    if retrain_mode == "pc":
        # --- Retrain PC mode ---
        source_folder = os.path.join(root_path, "original_model", args.dataset_name)
        model_folder_name = f"{args.dataset_name}_depth_{args.depth_start}_thr_{args.voxel_thr}_PC{suffix}"
        new_model_folder = os.path.join(root_path, "retrain_model", model_folder_name)
        print(f"[DEBUG] Copying folder from {source_folder} to {new_model_folder}")
        if os.path.exists(new_model_folder):
            shutil.rmtree(new_model_folder)
        shutil.copytree(source_folder, new_model_folder)
        
        for item in os.listdir(new_model_folder):
            if item not in ["cameras.json", "cfg_args"]:
                item_path = os.path.join(new_model_folder, item)
                if os.path.isdir(item_path):
                    shutil.rmtree(item_path)
                else:
                    os.remove(item_path)
        
        new_input_path = os.path.join(new_model_folder, "input.ply")
        print(f"[DEBUG] Copying PC ply file from {pc_ply_file} to {new_input_path}")
        shutil.copy(pc_ply_file, new_input_path)
        
        retrain_pc_dir = os.path.join(root_path, "code_Adaptive", "retrain_PC")
        # Define render_script_path in the PC branch
        render_script_path = os.path.join(retrain_pc_dir, "render.py")
        model_path = new_model_folder
        colmap_path = os.path.join(root_path, "colmap_dataset", args.dataset_name)
        
        train_command = [
            sys.executable, "train.py",
            "-s", os.path.join("..", "..", "colmap_dataset", args.dataset_name),
            "-m", os.path.join("..", "..", "retrain_model", model_folder_name),
            "--data_device", "cuda",
            "--iterations", str(iterations),
            "--eval"
        ]
        print(f"[DEBUG] Running train command: {' '.join(train_command)}")
        subprocess.check_call(train_command, cwd=retrain_pc_dir)

        # Rendering command loop
        for iteration in range(1000, 5001, 1000):
            render_command = [
                "python",
                render_script_path,
                "-m", model_path,
                "-s", colmap_path,
                "--iteration", str(iteration)
            ]
            print(f"[DEBUG] Running render command: {' '.join(render_command)}")
            try:
                subprocess.run(render_command, check=True)
            except subprocess.CalledProcessError as e:
                print(f"[WARNING] Render command failed for iteration {iteration}: {e}. Continuing to next iteration.")
                continue


        metrics_command = [
            sys.executable, "metrics.py",
            "-m", os.path.join("..", "..", "retrain_model", model_folder_name)
        ]
        print(f"[DEBUG] Running metrics command: {' '.join(metrics_command)}")
        subprocess.check_call(metrics_command, cwd=retrain_pc_dir)

        
    elif retrain_mode == "3dgs":
        # --- Retrain 3DGS mode ---
        # Define the directory of retrain_3DGS scripts (assumed to be in root_path/code_Adaptive/retrain_3DGS)
        retrain_3dgs_dir = os.path.join(root_path, "code_Adaptive", "retrain_3DGS")
        train_script_path = os.path.join(retrain_3dgs_dir, "train.py")
        render_script_path = os.path.join(retrain_3dgs_dir, "render.py")
        metrics_script_path = os.path.join(retrain_3dgs_dir, "metrics.py")
        
        # Assume model_path is a newly created folder under retrain_model (create if it doesn't exist)
        model_folder_name = f"{args.dataset_name}_depth_{args.depth_start}_thr_{args.voxel_thr}_3DGS{suffix}"
        model_path = os.path.join(root_path, "retrain_model", model_folder_name)
        if not os.path.exists(model_path):
            os.makedirs(model_path)
        colmap_path = os.path.join(root_path, "colmap_dataset", args.dataset_name)
        # Use the 3DGS ply file generated by adapt_voxel_recolor.py as the start_pointcloud argument
        pointcloud_path = full_ply_file
        
        train_command = [
            "python",
            train_script_path,
            "-m", model_path,
            "-s", colmap_path,
            "--eval", "--data_device", "cuda",
            "--iterations", str(iterations),
            "--start_pointcloud", pointcloud_path
        ]
        print(f"[DEBUG] Running train command: {' '.join(train_command)}")
        subprocess.run(train_command, check=True)
        
        # Rendering
        for iteration in range(1000, 5001, 1000):
            render_command = [
                "python",
                render_script_path,
                "-m", model_path,
                "-s", colmap_path,
                "--iteration", str(iteration)
            ]
            print(f"[DEBUG] Running render command: {' '.join(render_command)}")
            try:
                subprocess.run(render_command, check=True)
            except subprocess.CalledProcessError as e:
                print(f"[WARNING] Render command failed for iteration {iteration}: {e}. Continuing to next iteration.")
                continue

        
        metrics_command = [
            "python",
            metrics_script_path,
            "-m", model_path
        ]
        print(f"[DEBUG] Running metrics command: {' '.join(metrics_command)}")
        subprocess.run(metrics_command, check=True)
    else:
        print(f"[ERROR] Unknown retrain_mode: {args.retrain_mode}. Expected 'PC' or '3DGS'.")
        sys.exit(1)

if __name__ == '__main__':
    main()

